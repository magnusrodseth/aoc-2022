use std::{cmp::Ordering, iter::Peekable};

#[derive(Eq, PartialEq, Debug, Clone, PartialOrd, Ord)]
struct Packet(Vec<Item>);

#[derive(Eq, PartialEq, Debug, Clone, PartialOrd, Ord)]
enum Item {
    Value(usize),
    Packet(Packet),
}

fn parse_item<I: Iterator<Item = u8>>(input: &mut Peekable<I>) -> Option<Item> {
    let first = *input.peek().expect("no first item");

    if (b'0'..b'9').contains(&first) {
        input.next();
        let mut item = first - b'0';

        if item == 1 {
            let next = *input.peek().expect("no next item");

            if next == b'0' {
                item = 10;
                input.next();
            }
        }

        Some(Item::Value(item as usize))
    } else if first == b']' {
        None
    } else {
        Some(Item::Packet(parse_packet(input)))
    }
}

fn parse_packet<I: Iterator<Item = u8>>(input: &mut Peekable<I>) -> Packet {
    let mut items = Vec::new();

    while let Some(item) = input.next() {
        match item {
            b',' | b'[' => {
                if let Some(item) = parse_item(input) {
                    items.push(item);
                }
            }
            b']' => return Packet(items),
            _ => unreachable!("Unexpected character"),
        }
    }

    Packet(items)
}

fn part1(input: &str) -> usize {
    let parsed = input
        .split("\n\n")
        .map(|line| {
            let (first, second) = line.split_once('\n').expect("Invalid input");
            dbg!(&first, &second);

            let (mut first, mut second) = (
                first.as_bytes().iter().copied().peekable(),
                second.as_bytes().iter().copied().peekable(),
            );

            (parse_packet(&mut first), parse_packet(&mut second))
        })
        .collect::<Vec<_>>();

    let pairs_in_correct_order = parsed
        .iter()
        .enumerate()
        .filter(|(_, (first, second))| first.cmp(second) == Ordering::Less)
        .map(|(i, _)| i + 1)
        .sum::<usize>();

    pairs_in_correct_order
}

fn part2(input: &str) -> usize {
    0
}

pub fn solve() {
    let input = include_str!("../../input/day13.txt");

    println!("Day 1 Part 1: {:?}", part1(input));
    println!("Day 1 Part 2: {:?}", part2(input));
}

#[cfg(test)]
mod tests {
    use super::*;

    const INPUT: &str = "[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]";

    #[test]
    fn day13_part1() {
        assert_eq!(part1(INPUT), 13);
    }

    #[test]
    #[ignore = "not implemented yet"]
    fn day13_part2() {
        assert_eq!(part2(INPUT), 1);
    }
}
